export const metadata = {
  title: 'On Control Flow',
  date: '2025.09.30',
  description: 'How systems become what they were never meant to be',
}

# On Control Flow

> "There are no facts, only interpretations."
>
>  â€” Friedrich Nietzsche

The hardware has [memory addresses](https://en.wikipedia.org/wiki/Memory_address), and nothing about an address says who put it there or why. What a programmer writes as a function call is, at the machine level, an address being loaded into a register and jumped to. Those addresses live in memory that can be written to.

## Pointers

A [function pointer](https://en.wikipedia.org/wiki/Function_pointer)'s destination lives in memory alongside program data, resolved only when the call actually happens.

In this struct, a 64-byte buffer sits next to a function pointer.
```c
struct Object {
    char buffer[64];
    void (*handler)(char *data);
};

void process(struct Object *obj, char *input) {
    strcpy(obj->buffer, input);
    obj->handler(obj->buffer);
}
```

Here, `handler` is a legitimate function pointer that gets called after the buffer is filled. Since `strcpy` doesn't check bounds, [overflowing the buffer](https://en.wikipedia.org/wiki/Buffer_overflow) writes past its 64 bytes and into `handler`.

<BlockSideTitle title={<>
  The buffer and function pointer are adjacent in memory.
</>}>
```
+---------------------+
|  buffer (64 bytes)    |  <- input
+---------------------+
|  handler (8 bytes)    |  <- overflow
+---------------------+
```
</BlockSideTitle>

When the program calls `obj->handler()`, it jumps to whatever address is stored there.

At runtime, C++ vtables, callbacks, and any other indirect call are all just addresses being dereferenced and jumped to. The processor executes whatever address ends up in the register, whether it came from a legitimate call or corrupted memory.

[CFI](https://en.wikipedia.org/wiki/Control-flow_integrity) checks that indirect calls target valid functions, and [CET](https://www.intel.com/content/www/us/en/developer/articles/technical/technical-look-control-flow-enforcement-technology.html) uses hardware shadow stacks to verify return addresses, adding hardware enforcement to what was previously just software convention.

## Overflow

To the hardware, the programmer's intended call and the attacker's payload are both just an address. The only fact is whatever ends up in the register, and everything else was just interpretation.